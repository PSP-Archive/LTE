.TH "engine::scene::ISceneManager" 3 "29 Jul 2006" "LTE 3D Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
engine::scene::ISceneManager \- The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <ISceneManager.h>\fP
.PP
Inherits \fBengine::IUnknown\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~ISceneManager\fP ()"
.br
.RI "\fIdestructor \fP"
.ti -1c
.RI "virtual \fBIAnimatedMesh\fP * \fBgetMesh\fP (const c8 *filename)=0"
.br
.RI "\fIReturns pointer to an animateable mesh. Loads the file if not loaded already. \fP"
.ti -1c
.RI "virtual \fBIMeshCache\fP * \fBgetMeshCache\fP ()=0"
.br
.RI "\fIReturns an interface to the mesh cache which is shared beween all existing scene managers. \fP"
.ti -1c
.RI "virtual \fBvideo::IVideoDriver\fP * \fBgetVideoDriver\fP ()=0"
.br
.RI "\fIReturns the video driver. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddTestSceneNode\fP (f32 size=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &position=core::vector3df(0, 0, 0), const core::vector3df &rotation=core::vector3df(0, 0, 0), const core::vector3df &scale=core::vector3df(1.0f, 1.0f, 1.0f))=0"
.br
.RI "\fIAdds a test scene node for test purposes to the scene. \fP"
.ti -1c
.RI "virtual \fBIAnimatedMeshSceneNode\fP * \fBaddAnimatedMeshSceneNode\fP (\fBIAnimatedMesh\fP *mesh, \fBISceneNode\fP *parent=0, s32 id=-1, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &rotation=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &scale=\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f))=0"
.br
.RI "\fIAdds a scene node for rendering an animated mesh model. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddMeshSceneNode\fP (\fBIMesh\fP *mesh, \fBISceneNode\fP *parent=0, s32 id=-1, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &rotation=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &scale=\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f))=0"
.br
.RI "\fIAdds a scene node for rendering a static mesh. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddWaterSurfaceSceneNode\fP (\fBIMesh\fP *mesh, f32 waveHeight=2.0f, f32 waveSpeed=300.0f, f32 waveLength=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &position=core::vector3df(0, 0, 0), const core::vector3df &rotation=core::vector3df(0, 0, 0), const core::vector3df &scale=core::vector3df(1.0f, 1.0f, 1.0f))=0"
.br
.RI "\fIAdds a scene node for rendering a animated water surface mesh. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddOctTreeSceneNode\fP (\fBIAnimatedMesh\fP *mesh, \fBISceneNode\fP *parent=0, s32 id=-1, s32 minimalPolysPerNode=128)=0"
.br
.RI "\fIAdds a scene node for rendering using a octtree to the scene graph. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddOctTreeSceneNode\fP (\fBIMesh\fP *mesh, \fBISceneNode\fP *parent=0, s32 id=-1, s32 minimalPolysPerNode=128)=0"
.br
.RI "\fIAdds a scene node for rendering using a octtree to the scene graph. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddBspSceneNode\fP (void *mesh, \fBISceneNode\fP *parent=0, s32 id=-1, s32 minimalPolysPerNode=128)=0"
.br
.RI "\fIAdds a scene node for rendering using bsp tree to the scene graph. \fP"
.ti -1c
.RI "virtual \fBICameraSceneNode\fP * \fBaddCameraSceneNode\fP (\fBISceneNode\fP *parent=0, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &lookat=\fBcore::vector3df\fP(0, 0, 100), s32 id=-1)=0"
.br
.RI "\fIAdds a camera scene node to the scene graph and sets it as active camera. \fP"
.ti -1c
.RI "virtual \fBICameraSceneNode\fP * \fBaddCameraSceneNodeMaya\fP (\fBISceneNode\fP *parent=0, f32 rotateSpeed=-1500.0f, f32 zoomSpeed=200.0f, f32 translationSpeed=1500.0f, s32 id=-1)=0"
.br
.RI "\fIAdds a maya style user controlled camera scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBICameraSceneNode\fP * \fBaddCameraSceneNodeFPS\fP (\fBISceneNode\fP *parent=0, f32 rotateSpeed=100.0f, f32 moveSpeed=500.0f, s32 id=-1, SKeyMap *keyMapArray=0, s32 keyMapSize=0, bool noVerticalMovement=false, int moveStyle=0)=0"
.br
.RI "\fIAdds a camera scene node which is able to be controlled with the analog and keys like in most first person shooters (FPS). \fP"
.ti -1c
.RI "virtual \fBILightSceneNode\fP * \fBaddLightSceneNode\fP (\fBISceneNode\fP *parent=0, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0, 0, 0), \fBvideo::SColorf\fP color=\fBvideo::SColorf\fP(1.0f, 1.0f, 1.0f), f32 radius=100.0f, s32 id=-1)=0"
.br
.RI "\fIAdds a dynamic light scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBIBillboardSceneNode\fP * \fBaddBillboardSceneNode\fP (\fBISceneNode\fP *parent=0, const \fBcore::dimension2d\fP< f32 > &size=\fBcore::dimension2d\fP< f32 >(10.0f, 10.0f), const core::vector3df &position=core::vector3df(0, 0, 0), s32 id=-1)=0"
.br
.RI "\fIAdds a billboard scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddSkyBoxSceneNode\fP (\fBvideo::ITexture\fP *top, \fBvideo::ITexture\fP *bottom, \fBvideo::ITexture\fP *left, \fBvideo::ITexture\fP *right, \fBvideo::ITexture\fP *front, \fBvideo::ITexture\fP *back, \fBISceneNode\fP *parent=0, s32 id=-1)=0"
.br
.RI "\fIAdds a skybox scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBIParticleSystemSceneNode\fP * \fBaddParticleSystemSceneNode\fP (bool withDefaultEmitter=true, \fBISceneNode\fP *parent=0, s32 id=-1, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &rotation=\fBcore::vector3df\fP(0, 0, 0), const \fBcore::vector3df\fP &scale=\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f))=0"
.br
.RI "\fIAdds a particle system scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBITerrainSceneNode\fP * \fBaddTerrainSceneNode\fP (const char *heightMapFileName, \fBISceneNode\fP *parent=0, s32 id=-1, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0.0f, 0.0f, 0.0f), const core::vector3df &rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17)=0"
.br
.RI "\fIAdds a terrain scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBITerrainSceneNode\fP * \fBaddTerrainSceneNode\fP (\fBio::IReadFile\fP *heightMapFile, \fBISceneNode\fP *parent=0, s32 id=-1, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0.0f, 0.0f, 0.0f), const core::vector3df &rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17)=0"
.br
.RI "\fIAdds a terrain scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBaddEmptySceneNode\fP (\fBISceneNode\fP *parent=0, s32 id=-1)=0"
.br
.RI "\fIAdds an empty scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBIDummyTransformationSceneNode\fP * \fBaddDummyTransformationSceneNode\fP (\fBISceneNode\fP *parent=0, s32 id=-1)=0"
.br
.RI "\fIAdds a dummy transformation scene node to the scene graph. \fP"
.ti -1c
.RI "virtual \fBITextSceneNode\fP * \fBaddTextSceneNode\fP (\fBgui::IGUIFont\fP *font, const wchar_t *text, \fBvideo::SColor\fP color=\fBvideo::SColor\fP(100, 255, 255, 255), \fBISceneNode\fP *parent=0, const \fBcore::vector3df\fP &position=\fBcore::vector3df\fP(0, 0, 0), s32 id=-1)=0"
.br
.RI "\fIAdds a text scene node, which is able to display 2d text at a position in three dimensional space. \fP"
.ti -1c
.RI "virtual \fBIAnimatedMesh\fP * \fBaddHillPlaneMesh\fP (const c8 *name, const \fBcore::dimension2d\fP< f32 > &tileSize, const \fBcore::dimension2d\fP< s32 > &tileCount, \fBvideo::SMaterial\fP *material=0, f32 hillHeight=0.0f, const core::dimension2d< f32 > &countHills=core::dimension2d< f32 >(0.0f, 0.0f), const core::dimension2d< f32 > &textureRepeatCount=core::dimension2d< f32 >(1.0f, 1.0f))=0"
.br
.RI "\fIAdds a Hill Plane mesh to the mesh pool. \fP"
.ti -1c
.RI "virtual \fBIAnimatedMesh\fP * \fBaddTerrainMesh\fP (const c8 *meshname, \fBvideo::IImage\fP *texture, \fBvideo::IImage\fP *heightmap, const \fBcore::dimension2d\fP< f32 > &stretchSize=\fBcore::dimension2d\fP< f32 >(10.0f, 10.0f), f32 maxHeight=200.0f, const core::dimension2d< s32 > &defaultVertexBlockSize=core::dimension2d< s32 >(64, 64))=0"
.br
.RI "\fIAdds a static terrain mesh to the mesh pool. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBgetRootSceneNode\fP ()=0"
.br
.RI "\fIReturns the root scene node. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBgetSceneNodeFromId\fP (s32 id, \fBISceneNode\fP *start=0)=0"
.br
.RI "\fIReturns the first scene node with the specified id. \fP"
.ti -1c
.RI "virtual \fBISceneNode\fP * \fBgetSceneNodeFromName\fP (const wchar_t *name, \fBISceneNode\fP *start=0)=0"
.br
.RI "\fIReturns the first scene node with the specified name. \fP"
.ti -1c
.RI "virtual \fBICameraSceneNode\fP * \fBgetActiveCamera\fP ()=0"
.br
.RI "\fIReturns the current active camera. \fP"
.ti -1c
.RI "virtual void \fBsetActiveCamera\fP (\fBICameraSceneNode\fP *camera)=0"
.br
.RI "\fISets the currently active camera. \fP"
.ti -1c
.RI "virtual void \fBsetShadowColor\fP (\fBvideo::SColor\fP color=\fBvideo::SColor\fP(150, 0, 0, 0))=0"
.br
.RI "\fISets the color of stencil buffers shadows drawn by the scene manager. \fP"
.ti -1c
.RI "virtual \fBvideo::SColor\fP \fBgetShadowColor\fP () const =0"
.br
.RI "\fIReturns the current color of shadows. \fP"
.ti -1c
.RI "virtual void \fBregisterNodeForRendering\fP (\fBISceneNode\fP *node, \fBE_SCENE_NODE_RENDER_PASS\fP pass=ESNRP_AUTOMATIC)=0"
.br
.RI "\fIRegisters a node for rendering it at a specific time. \fP"
.ti -1c
.RI "virtual void \fBdrawAll\fP ()=0"
.br
.RI "\fIDraws all the scene nodes. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimator\fP * \fBcreateRotationAnimator\fP (const \fBcore::vector3df\fP &rotationPerSecond)=0"
.br
.RI "\fICreates a rotation animator, which rotates the attached scene node around itself. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimator\fP * \fBcreateFlyCircleAnimator\fP (const \fBcore::vector3df\fP &center, f32 radius, f32 speed=0.001f)=0"
.br
.RI "\fICreates a fly circle animator, which lets the attached scene node fly around a center. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimator\fP * \fBcreateFlyStraightAnimator\fP (const \fBcore::vector3df\fP &startPoint, const \fBcore::vector3df\fP &endPoint, u32 timeForWay, bool loop=false)=0"
.br
.RI "\fICreates a fly straight animator, which lets the attached scene node fly or move along a line between two points. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimator\fP * \fBcreateTextureAnimator\fP (const \fBcore::array\fP< \fBvideo::ITexture\fP * > &textures, s32 timePerFrame, bool loop=true)=0"
.br
.RI "\fICreates a texture animator, which switches the textures of the target scene node based on a list of textures. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimator\fP * \fBcreateDeleteAnimator\fP (u32 timeMs)=0"
.br
.RI "\fICreates a scene node animator, which deletes the scene node after some time automaticly. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimatorCollisionResponse\fP * \fBcreateCollisionResponseAnimator\fP (\fBITriangleSelector\fP *world, \fBISceneNode\fP *sceneNode, const \fBcore::vector3df\fP &ellipsoidRadius=\fBcore::vector3df\fP(30, 60, 30), const \fBcore::vector3df\fP &gravityPerSecond=\fBcore::vector3df\fP(0,-100.0f, 0), const core::vector3df &ellipsoidTranslation=core::vector3df(0, 0, 0), f32 slidingValue=0.0005f)=0"
.br
.RI "\fICreates a special scene node animator for doing automatic collision detection and response. \fP"
.ti -1c
.RI "virtual \fBISceneNodeAnimator\fP * \fBcreateFollowSplineAnimator\fP (s32 startTime, const \fBcore::array\fP< \fBcore::vector3df\fP > &points, f32 speed=1.0f, f32 tightness=0.5f)=0"
.br
.RI "\fICreates a follow spline animator. \fP"
.ti -1c
.RI "virtual \fBITriangleSelector\fP * \fBcreateTriangleSelector\fP (\fBIMesh\fP *mesh, \fBISceneNode\fP *node)=0"
.br
.RI "\fICreates a simple \fBITriangleSelector\fP, based on a mesh. \fP"
.ti -1c
.RI "virtual \fBITriangleSelector\fP * \fBcreateTriangleSelectorFromBoundingBox\fP (\fBISceneNode\fP *node)=0"
.br
.RI "\fICreates a simple dynamic \fBITriangleSelector\fP, based on a axis aligned bounding box. \fP"
.ti -1c
.RI "virtual \fBITriangleSelector\fP * \fBcreateOctTreeTriangleSelector\fP (\fBIMesh\fP *mesh, \fBISceneNode\fP *node, s32 minimalPolysPerNode=32)=0"
.br
.RI "\fICreates a Triangle Selector, optimized by an octtree. \fP"
.ti -1c
.RI "virtual \fBIMetaTriangleSelector\fP * \fBcreateMetaTriangleSelector\fP ()=0"
.br
.RI "\fICreates a meta triangle selector. \fP"
.ti -1c
.RI "virtual \fBITriangleSelector\fP * \fBcreateTerrainTriangleSelector\fP (\fBITerrainSceneNode\fP *node, s32 LOD=0)=0"
.br
.RI "\fICreates a triangle selector which can select triangles from a terrain scene node. \fP"
.ti -1c
.RI "virtual void \fBaddExternalMeshLoader\fP (\fBIMeshLoader\fP *externalLoader)=0"
.br
.RI "\fIAdds an external mesh loader for extending the engine with new file formats. \fP"
.ti -1c
.RI "virtual \fBISceneCollisionManager\fP * \fBgetSceneCollisionManager\fP ()=0"
.br
.RI "\fIReturns a pointer to the scene collision manager. \fP"
.ti -1c
.RI "virtual \fBIMeshManipulator\fP * \fBgetMeshManipulator\fP ()=0"
.br
.RI "\fIReturns a pointer to the mesh manipulator. \fP"
.ti -1c
.RI "virtual void \fBaddToDeletionQueue\fP (\fBISceneNode\fP *node)=0"
.br
.RI "\fIAdds a scene node to the deletion queue. \fP"
.ti -1c
.RI "virtual bool \fBpostEventFromUser\fP (\fBSEvent\fP event)=0"
.br
.RI "\fIPosts an input event to the environment. \fP"
.ti -1c
.RI "virtual void \fBclear\fP ()=0"
.br
.RI "\fIClears the whole scene. \fP"
.ti -1c
.RI "virtual \fBIStringParameters\fP * \fBgetParameters\fP ()=0"
.br
.RI "\fIReturns interface to the parameters set in this scene. \fP"
.ti -1c
.RI "virtual \fBE_SCENE_NODE_RENDER_PASS\fP \fBgetSceneNodeRenderPass\fP ()=0"
.br
.RI "\fIReturns current render pass. \fP"
.ti -1c
.RI "virtual \fBISceneManager\fP * \fBcreateNewSceneManager\fP ()=0"
.br
.RI "\fICreates a new scene manager. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff. 

All Scene nodes can be created only here. There is a always growing list of scene nodes for lots of purposes: Indoor rendering scene nodes like the Octree (\fBaddOctTreeSceneNode()\fP) or the terrain renderer (\fBaddTerrainSceneNode()\fP), different Camera scene nodes (\fBaddCameraSceneNode()\fP, \fBaddCameraSceneNodeMaya()\fP), scene nodes for Light (\fBaddLightSceneNode()\fP), Billboards (\fBaddBillboardSceneNode()\fP) and so on. A scene node is a node in the hirachical scene graph. Every scene node may have children, which are other scene nodes. Children move relative the their parents position. If the parent of a node is not visible, its children won't be visible too. In this way, it is for example easily possible to attach a light to a moving car, or to place a walking character on a moving platform on a moving ship. The SceneManager is also able to load 3d mesh files of different formats. Take a look at \fBgetMesh()\fP to find out what formats are supported. And if these formats are not enough for you can use \fBaddExternalMeshLoader()\fP to add your own format to the engine. 
.PP
.SH "Member Function Documentation"
.PP 
.SS "virtual \fBIAnimatedMeshSceneNode\fP* engine::scene::ISceneManager::addAnimatedMeshSceneNode (\fBIAnimatedMesh\fP * mesh, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP)\fC [pure virtual]\fP"
.PP
Adds a scene node for rendering an animated mesh model. 
.PP
\fBParameters:\fP
.RS 4
\fImesh,:\fP Pointer to the loaded animated mesh to be displayed. 
.br
\fIparent,:\fP Parent of the scene node. Can be NULL if no parent. 
.br
\fIid,:\fP Id of the node. This id can be used to identify the scene node. 
.br
\fIposition,:\fP Position of the space relative to its parent where the scene node will be placed. 
.br
\fIrotation,:\fP Initital rotation of the scene node. 
.br
\fIscale,:\fP Initial scale of the scene node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBIBillboardSceneNode\fP* engine::scene::ISceneManager::addBillboardSceneNode (\fBISceneNode\fP * parent = \fC0\fP, const \fBcore::dimension2d\fP< f32 > & size = \fC\fBcore::dimension2d\fP< f32 >(10.0f, 10.0f)\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds a billboard scene node to the scene graph. 
.PP
A billboard is like a 3d sprite: A 2d element, which always looks to the camera. It is usually used for things like explosions, fire, lensflares and things like that. 
.PP
\fBParameters:\fP
.RS 4
\fIparent,:\fP Parent scene node of the billboard. Can be null. If the parent moves, the billboard will move too. 
.br
\fIposition,:\fP Position of the space relative to its parent where the billboard will be placed. 
.br
\fIsize,:\fP Size of the billboard. This size is 2 dimensional because a billboard only has width and height. 
.br
\fIid,:\fP An id of the node. This id can be used to identify the node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the billboard if successful, otherwise NULL. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBICameraSceneNode\fP* engine::scene::ISceneManager::addCameraSceneNode (\fBISceneNode\fP * parent = \fC0\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & lookat = \fC\fBcore::vector3df\fP(0, 0, 100)\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds a camera scene node to the scene graph and sets it as active camera. 
.PP
This camera does not react on user input like for example the one created with \fBaddCameraSceneNodeFPS()\fP. If you want to move or animate it, use animators or the \fBISceneNode::setPosition()\fP, \fBICameraSceneNode::setTarget()\fP etc methods. 
.PP
\fBParameters:\fP
.RS 4
\fIposition,:\fP Position of the space relative to its parent where the camera will be placed. 
.br
\fIlookat,:\fP Position where the camera will look at. Also known as target. 
.br
\fIparent,:\fP Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. 
.br
\fIid,:\fP id of the camera. This id can be used to identify the camera. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to interface to camera if successful, otherwise 0. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBICameraSceneNode\fP* engine::scene::ISceneManager::addCameraSceneNodeFPS (\fBISceneNode\fP * parent = \fC0\fP, f32 rotateSpeed = \fC100.0f\fP, f32 moveSpeed = \fC500.0f\fP, s32 id = \fC-1\fP, \fBSKeyMap\fP * keyMapArray = \fC0\fP, s32 keyMapSize = \fC0\fP, bool noVerticalMovement = \fCfalse\fP, int moveStyle = \fC0\fP)\fC [pure virtual]\fP"
.PP
Adds a camera scene node which is able to be controlled with the analog and keys like in most first person shooters (FPS). 
.PP
Add a camera scene node fps controlled by the control keys of the PSP. There are three style of this camera, see the moveStyle for further information. The first moveStyle is default and sets that you can move the camera with the d-pad and rotate it with the analog, for all move styles you can set a custom keymap. A custom keymap let you to use your prefered controls to move/rotate the camera. For example. 
.PP
.nf
            SKeyMap keyMap[4];
                 keyMap[0].Action = EKA_MOVE_FORWARD;
                 keyMap[0].KeyCode = KEY_TRIANGLE;
                
                 keyMap[2].Action = EKA_MOVE_BACKWARD;
                 keyMap[2].KeyCode = KEY_CROSS;
                
                 keyMap[4].Action = EKA_STRAFE_LEFT;
                 keyMap[4].KeyCode = KEY_SQUARE;

                 keyMap[6].Action = EKA_STRAFE_RIGHT;
                 keyMap[6].KeyCode = KEY_CIRCLE;

                
                 camera = sceneManager->addCameraSceneNodeFPS(0, 100, 500, -1, keyMap, 4, false, 0);

.fi
.PP
 This code adds a camera scene node fps with a custom keymap to move the camera with triangle, cross, square and circle.
.PP
The better moveStyle for FPS games is the third (moveStyle = 2), it lets you to use the analog to move and rotate the camera: with analog left you rotate left, with analog right you rotate right, with analog up you move forward and with analog down you move backward.
.PP
\fBParameters:\fP
.RS 4
\fIparent,:\fP Parent scene node of the camera. Can be null. 
.br
\fIrotateSpeed,:\fP Speed with wich the camera is rotated. This can be done only with the mouse. 
.br
\fImovespeed,:\fP Speed with which the camera is moved. Movement is done with the cursor keys. 
.br
\fIid,:\fP id of the camera. This id can be used to identify the camera. 
.br
\fIkeyMapArray,:\fP Optional pointer to an array of a keymap, specifying what keys should be used to move the camera. If this is null, the default keymap is used. You can define actions more then one time in the array, to bind multiple keys to the same action. 
.br
\fIkeyMapSize,:\fP Amount of items in the keymap array. 
.br
\fInoVerticalMovement,:\fP Setting this to true makes the camera only move within a horizontal plane, and disables vertical movement as known from most ego shooters. Default is 'false', with which it is possible to fly around in space, if no gravity is there. 
.br
\fImoveStyle,:\fP sets the movement style for the camera: 0 = Analog to rotate the camera, DPad to move the camera. Custom keymaps can be used to replace the movement controls. 1 = Analog to move the camera. DPad to rotate the camera. Custom keymaps can be used to replace the controls to rotate the camera. 2 = Analog left and right rotate the camera, analog up and down move the camera. Custom actions EKA_MOVE_FORWARD and EKA_MOVE_BACKWARD rotate up and down the camera; EKA_STRAFE_LEFT and EKA_STRAFE_RIGHT move the camera left and right. By default you can rotate the camera up and down with D-PAD UP and DOWN and to move the camera left and right: D-PAD LEFT and RIGHT. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBICameraSceneNode\fP* engine::scene::ISceneManager::addCameraSceneNodeMaya (\fBISceneNode\fP * parent = \fC0\fP, f32 rotateSpeed = \fC-1500.0f\fP, f32 zoomSpeed = \fC200.0f\fP, f32 translationSpeed = \fC1500.0f\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds a maya style user controlled camera scene node to the scene graph. 
.PP
The maya camera is able to be controlled with the mouse similar like in the 3D Software Maya by Alias Wavefront. 
.PP
\fBParameters:\fP
.RS 4
\fIparent,:\fP Parent scene node of the camera. Can be null. 
.br
\fIrotateSpeed,:\fP Rotation speed of the camera. 
.br
\fIzoomSpeed,:\fP Zoom speed of the camera. 
.br
\fItranlationSpeed,:\fP TranslationSpeed of the camera. 
.br
\fIid,:\fP id of the camera. This id can be used to identify the camera. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBIDummyTransformationSceneNode\fP* engine::scene::ISceneManager::addDummyTransformationSceneNode (\fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds a dummy transformation scene node to the scene graph. 
.PP
This scene node does not render itself, and does not respond to set/getPosition, set/getRotation and set/getScale. Its just a simple scene node that takes a matrix as relative transformation, making it possible to insert any transformation anywhere into the scene graph. 
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addEmptySceneNode (\fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds an empty scene node to the scene graph. 
.PP
Can be used for doing advanced transformations or structuring the scene graph. 
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual void engine::scene::ISceneManager::addExternalMeshLoader (\fBIMeshLoader\fP * externalLoader)\fC [pure virtual]\fP"
.PP
Adds an external mesh loader for extending the engine with new file formats. 
.PP
If you want the engine to be extended with file formats it currently is not able to load (e.g. .cob), just implement the \fBIMeshLoader\fP interface in your loading class and add it with this method. Using this method it is also possible to override built-in mesh loaders with newer or updated versions without the need of recompiling the engine. 
.PP
\fBParameters:\fP
.RS 4
\fIexternalLoader,:\fP Implementation of a new mesh loader. 
.RE
.PP

.SS "virtual \fBIAnimatedMesh\fP* engine::scene::ISceneManager::addHillPlaneMesh (const c8 * name, const \fBcore::dimension2d\fP< f32 > & tileSize, const \fBcore::dimension2d\fP< s32 > & tileCount, \fBvideo::SMaterial\fP * material = \fC0\fP, f32 hillHeight = \fC0.0f\fP, const \fBcore::dimension2d\fP< f32 > & countHills = \fC\fBcore::dimension2d\fP< f32 >(0.0f, 0.0f)\fP, const \fBcore::dimension2d\fP< f32 > & textureRepeatCount = \fC\fBcore::dimension2d\fP< f32 >(1.0f, 1.0f)\fP)\fC [pure virtual]\fP"
.PP
Adds a Hill Plane mesh to the mesh pool. 
.PP
The mesh is generated on the fly and looks like a plane with some hills on it. It is uses mostly for quick tests of the engine only. You can specify how many hills there should be on the plane and how high they should be. Also you must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retieved again using \fBISceneManager::getMesh()\fP with the name as parameter. 
.PP
\fBParameters:\fP
.RS 4
\fIname,:\fP The name of this mesh which must be specified in order to be able to retrieve the mesh later with \fBISceneManager::getMesh()\fP. 
.br
\fItileSize,:\fP Size of a tile of the mesh. (10.0f, 10.0f) would be a good value to start, for example. 
.br
\fItileCount,:\fP Specifies how much tiles there will be. If you specifiy for example that a tile has the size (10.0f, 10.0f) and the tileCount is (10,10), than you get a field of 100 tiles wich has the dimension 100.0fx100.0f. 
.br
\fImaterial,:\fP Material of the hill mesh. 
.br
\fIhillHeight,:\fP Height of the hills. If you specify a negative value you will get holes instead of hills. If the height is 0, no hills will be created. 
.br
\fIcountHills,:\fP Amount of hills on the plane. There will be countHills.X hills along the X axis and countHills.Y along the Y axis. So in total there will be countHills.X * countHills.Y hills. 
.br
\fItextureRepeatCount,:\fP Defines how often the texture will be repeated in x and y direction. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns null if the creation failed. The reason could be that you specified some invalid parameters or that a mesh with that name already exists. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBILightSceneNode\fP* engine::scene::ISceneManager::addLightSceneNode (\fBISceneNode\fP * parent = \fC0\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, \fBvideo::SColorf\fP color = \fC\fBvideo::SColorf\fP(1.0f, 1.0f, 1.0f)\fP, f32 radius = \fC100.0f\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds a dynamic light scene node to the scene graph. 
.PP
The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video::MTF_LIGHTING turned on. (This is the default setting in most scene nodes). 
.PP
\fBParameters:\fP
.RS 4
\fIparent,:\fP Parent scene node of the light. Can be null. If the parent moves, the light will move too. 
.br
\fIposition,:\fP Position of the space relative to its parent where the light will be placed. 
.br
\fIcolor,:\fP Diffuse color of the light. Ambient or Specular colors can be set manually with the \fBILightSceneNode::getLightData()\fP method. 
.br
\fIradius,:\fP Radius of the light. 
.br
\fIid,:\fP id of the node. This id can be used to identify the node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the interface of the light if successful, otherwise NULL. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addMeshSceneNode (\fBIMesh\fP * mesh, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP)\fC [pure virtual]\fP"
.PP
Adds a scene node for rendering a static mesh. 
.PP
\fBParameters:\fP
.RS 4
\fImesh,:\fP Pointer to the loaded static mesh to be displayed. 
.br
\fIparent,:\fP Parent of the scene node. Can be NULL if no parent. 
.br
\fIid,:\fP Id of the node. This id can be used to identify the scene node. 
.br
\fIposition,:\fP Position of the space relative to its parent where the scene node will be placed. 
.br
\fIrotation,:\fP Initital rotation of the scene node. 
.br
\fIscale,:\fP Initial scale of the scene node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addOctTreeSceneNode (\fBIMesh\fP * mesh, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, s32 minimalPolysPerNode = \fC128\fP)\fC [pure virtual]\fP"
.PP
Adds a scene node for rendering using a octtree to the scene graph. 
.PP
This a good method for rendering scenes with lots of geometry. The Octree is built on the fly from the mesh, much faster then a bsp tree. 
.PP
\fBParameters:\fP
.RS 4
\fImesh,:\fP The mesh containing all geometry from which the octtree will be build. 
.br
\fIparent,:\fP Parent node of the octtree node. 
.br
\fIid,:\fP id of the node. This id can be used to identify the node. 
.br
\fIminimalPolysPerNode,:\fP Specifies the minimal polygons contained a octree node. If a node gets less polys the this value, it will not be splitted into smaller nodes. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the pointer to the octtree if successful, otherwise 0. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addOctTreeSceneNode (\fBIAnimatedMesh\fP * mesh, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, s32 minimalPolysPerNode = \fC128\fP)\fC [pure virtual]\fP"
.PP
Adds a scene node for rendering using a octtree to the scene graph. 
.PP
This a good method for rendering scenes with lots of geometry. The Octree is built on the fly from the mesh. 
.PP
\fBParameters:\fP
.RS 4
\fImesh,:\fP The mesh containing all geometry from which the octtree will be build. If this animated mesh has more than one frames in it, the first frame is taken. 
.br
\fIparent,:\fP Parent node of the octtree node. 
.br
\fIid,:\fP id of the node. This id can be used to identify the node. 
.br
\fIminimalPolysPerNode,:\fP Specifies the minimal polygons contained a octree node. If a node gets less polys the this value, it will not be splitted into smaller nodes. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the pointer to the octtree if successful, otherwise 0. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBIParticleSystemSceneNode\fP* engine::scene::ISceneManager::addParticleSystemSceneNode (bool withDefaultEmitter = \fCtrue\fP, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP)\fC [pure virtual]\fP"
.PP
Adds a particle system scene node to the scene graph. 
.PP
\fBParameters:\fP
.RS 4
\fIwithDefaultEmitter,:\fP Creates a default working point emitter which emitts some particles. Set this to true to see a particle system in action. If set to false, you'll have to set the emitter you want by calling \fBIParticleSystemSceneNode::setEmitter()\fP. 
.br
\fIparent,:\fP Parent of the scene node. Can be NULL if no parent. 
.br
\fIid,:\fP Id of the node. This id can be used to identify the scene node. 
.br
\fIposition,:\fP Position of the space relative to its parent where the scene node will be placed. 
.br
\fIrotation,:\fP Initital rotation of the scene node. 
.br
\fIscale,:\fP Initial scale of the scene node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addSkyBoxSceneNode (\fBvideo::ITexture\fP * top, \fBvideo::ITexture\fP * bottom, \fBvideo::ITexture\fP * left, \fBvideo::ITexture\fP * right, \fBvideo::ITexture\fP * front, \fBvideo::ITexture\fP * back, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP)\fC [pure virtual]\fP"
.PP
Adds a skybox scene node to the scene graph. 
.PP
A skybox is a big cube with 6 textures on it and is drawed around the camera position. 
.PP
\fBParameters:\fP
.RS 4
\fItop,:\fP Texture for the top plane of the box. 
.br
\fIbottom,:\fP Texture for the bottom plane of the box. 
.br
\fIleft,:\fP Texture for the left plane of the box. 
.br
\fIright,:\fP Texture for the right plane of the box. 
.br
\fIfront,:\fP Texture for the front plane of the box. 
.br
\fIparent,:\fP Parent scene node of the skybox. A skybox usually has no parent, so this should be null. Note: If a parent is set to the skybox, the box will not change how it is drawed. 
.br
\fIid,:\fP An id of the node. This id can be used to identify the node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to the sky box if successful, otherwise NULL. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBIAnimatedMesh\fP* engine::scene::ISceneManager::addTerrainMesh (const c8 * meshname, \fBvideo::IImage\fP * texture, \fBvideo::IImage\fP * heightmap, const \fBcore::dimension2d\fP< f32 > & stretchSize = \fC\fBcore::dimension2d\fP< f32 >(10.0f, 10.0f)\fP, f32 maxHeight = \fC200.0f\fP, const \fBcore::dimension2d\fP< s32 > & defaultVertexBlockSize = \fC\fBcore::dimension2d\fP< s32 >(64, 64)\fP)\fC [pure virtual]\fP"
.PP
Adds a static terrain mesh to the mesh pool. 
.PP
The mesh is generated on the fly from a texture file and a height map file. Both files may be huge (8000x8000 pixels would be no problem) because the generator splits the files into smaller textures if necessary. You must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retieved again using \fBISceneManager::getMesh()\fP with the name as parameter. 
.PP
\fBParameters:\fP
.RS 4
\fImeshname,:\fP The name of this mesh which must be specified in order to be able to retrieve the mesh later with \fBISceneManager::getMesh()\fP. 
.br
\fItexture,:\fP Texture for the terrain. Please note that this is not a hardware texture as usual (ITexture), but an IImage software texture. You can load this texture with IVideoDriver::createImageFromFile(). 
.br
\fIheightmap,:\fP A grayscaled heightmap image. Like the texture, it can be created with IVideoDriver::createImageFromFile(). The amount of triangles created depends on the size of this texture, so use a small heightmap to increase rendering speed. 
.br
\fIstretchSize,:\fP Parameter defining how big a is pixel on the heightmap. 
.br
\fImaxHeight,:\fP Defines how height a white pixel on the heighmap is. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns null if the creation failed. The reason could be that you specified some invalid parameters, that a mesh with that name already exists, or that a texture could not be found. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBITerrainSceneNode\fP* engine::scene::ISceneManager::addTerrainSceneNode (\fBio::IReadFile\fP * heightMapFile, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0.0f, 0.0f, 0.0f)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0.0f, 0.0f, 0.0f)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP, \fBvideo::SColor\fP vertexColor = \fC\fBvideo::SColor\fP(255, 255, 255, 255)\fP, s32 maxLOD = \fC5\fP, \fBE_TERRAIN_PATCH_SIZE\fP patchSize = \fCETPS_17\fP)\fC [pure virtual]\fP"
.PP
Adds a terrain scene node to the scene graph. 
.PP
Just like the other \fBaddTerrainSceneNode()\fP method, but takes an IReadFile pointer as parameter for the heightmap. For more informations take a look add the other overload. 
.SS "virtual \fBITerrainSceneNode\fP* engine::scene::ISceneManager::addTerrainSceneNode (const char * heightMapFileName, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0.0f, 0.0f, 0.0f)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0.0f, 0.0f, 0.0f)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP, \fBvideo::SColor\fP vertexColor = \fC\fBvideo::SColor\fP(255, 255, 255, 255)\fP, s32 maxLOD = \fC5\fP, \fBE_TERRAIN_PATCH_SIZE\fP patchSize = \fCETPS_17\fP)\fC [pure virtual]\fP"
.PP
Adds a terrain scene node to the scene graph. 
.PP
This node implements is a simple terrain renderer which uses a technique known as geo mip mapping for reducing the detail of triangle blocks which are far away. The code for the TerrainSceneNode is based on the terrain renderer by Soconne and the GeoMipMapSceneNode developed by Spinz. They made their code available for engine and allowed it to be distributed under this licence. I only modified some parts. A lot of thanks go to them.
.PP
This scene node is capable of very quickly loading terrains and updating the indices at runtime to enable viewing very large terrains. It uses a CLOD (Continuous Level of Detail) algorithm which updates the indices for each patch based on a LOD (Level of Detail) which is determined based on a patch's distance from the camera.
.PP
The patch size of the terrain must always be a size of ( 2^N+1, i.e. 8+1(9), 16+1(17), etc. ). The MaxLOD available is directly dependent on the patch size of the terrain. LOD 0 contains all of the indices to draw all the triangles at the max detail for a patch. As each LOD goes up by 1 the step taken, in generating indices increases by - 2^LOD, so for LOD 1, the step taken is 2, for LOD 2, the step taken is 4, LOD 3 - 8, etc. The step can be no larger than the size of the patch, so having a LOD of 8, with a patch size of 17, is asking the algoritm to generate indices every 2^8 ( 256 ) vertices, which is not possible with a patch size of 17. The maximum LOD for a patch size of 17 is 2^4 ( 16 ). So, with a MaxLOD of 5, you'll have LOD 0 ( full detail ), LOD 1 ( every 2 vertices ), LOD 2 ( every 4 vertices ), LOD 3 ( every 8 vertices ) and LOD 4 ( every 16 vertices ). 
.PP
\fBParameters:\fP
.RS 4
\fIheightMapFile,:\fP The location of the file on disk, to read vertex data from. This should be a gray scale bitmap. 
.br
\fIposition,:\fP The absolute position of this node. 
.br
\fIrotation,:\fP The absolute rotation of this node. ( NOT YET IMPLEMENTED ) 
.br
\fIscale,:\fP The scale factor for the terrain. If you're using a heightmap of size 128x128 and would like your terrain to be 12800x12800 in game units, then use a scale factor of ( core::vector ( 100.0f, 100.0f, 100.0f ). If you use a Y scaling factor of 0.0f, then your terrain will be flat. 
.br
\fIvertexColor,:\fP The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. 
.br
\fImaxLOD,:\fP The maximum LOD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behaviour. 
.br
\fIpatchSize,:\fP patch size of the terrain. Only change if you know what you are doing, this might lead to strange behaviour. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addTestSceneNode (f32 size = \fC10.0f\fP, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP)\fC [pure virtual]\fP"
.PP
Adds a test scene node for test purposes to the scene. 
.PP
It is a simple cube of (1,1,1) size. 
.PP
\fBParameters:\fP
.RS 4
\fIsize,:\fP Size of the cube. 
.br
\fIparent,:\fP Parent of the scene node. Can be NULL if no parent. 
.br
\fIid,:\fP Id of the node. This id can be used to identify the scene node. 
.br
\fIposition,:\fP Position of the space relative to its parent where the scene node will be placed. 
.br
\fIrotation,:\fP Initital rotation of the scene node. 
.br
\fIscale,:\fP Initial scale of the scene node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created test scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual void engine::scene::ISceneManager::addToDeletionQueue (\fBISceneNode\fP * node)\fC [pure virtual]\fP"
.PP
Adds a scene node to the deletion queue. 
.PP
The scene node is immediatly deleted when it's secure. Which means when the scene node does not execute animators and things like that. This method is for example used for deleting scene nodes by their scene node animators. In most other cases, a \fBISceneNode::remove()\fP call is enough, using this deletion queue is not necessary. See \fBISceneManager::createDeleteAnimator()\fP for details. 
.PP
\fBParameters:\fP
.RS 4
\fInode,:\fP Node to detete. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::addWaterSurfaceSceneNode (\fBIMesh\fP * mesh, f32 waveHeight = \fC2.0f\fP, f32 waveSpeed = \fC300.0f\fP, f32 waveLength = \fC10.0f\fP, \fBISceneNode\fP * parent = \fC0\fP, s32 id = \fC-1\fP, const \fBcore::vector3df\fP & position = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & rotation = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, const \fBcore::vector3df\fP & scale = \fC\fBcore::vector3df\fP(1.0f, 1.0f, 1.0f)\fP)\fC [pure virtual]\fP"
.PP
Adds a scene node for rendering a animated water surface mesh. 
.PP
Looks really good when the Material type EMT_TRANSPARENT_REFLECTION is used. 
.PP
\fBParameters:\fP
.RS 4
\fIwaveHeight,:\fP Height of the water waves. 
.br
\fIwaveSpeed,:\fP Speed of the water waves. 
.br
\fIwaveLength,:\fP Lenght of a water wave. 
.br
\fImesh,:\fP Pointer to the loaded static mesh to be displayed with water waves on it. 
.br
\fIparent,:\fP Parent of the scene node. Can be NULL if no parent. 
.br
\fIid,:\fP Id of the node. This id can be used to identify the scene node. 
.br
\fIposition,:\fP Position of the space relative to its parent where the scene node will be placed. 
.br
\fIrotation,:\fP Initital rotation of the scene node. 
.br
\fIscale,:\fP Initial scale of the scene node. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the created scene node. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual void engine::scene::ISceneManager::clear ()\fC [pure virtual]\fP"
.PP
Clears the whole scene. 
.PP
All scene nodes are removed. 
.SS "virtual \fBISceneNodeAnimatorCollisionResponse\fP* engine::scene::ISceneManager::createCollisionResponseAnimator (\fBITriangleSelector\fP * world, \fBISceneNode\fP * sceneNode, const \fBcore::vector3df\fP & ellipsoidRadius = \fC\fBcore::vector3df\fP(30, 60, 30)\fP, const \fBcore::vector3df\fP & gravityPerSecond = \fC\fBcore::vector3df\fP(0,-100.0f, 0)\fP, const \fBcore::vector3df\fP & ellipsoidTranslation = \fC\fBcore::vector3df\fP(0, 0, 0)\fP, f32 slidingValue = \fC0.0005f\fP)\fC [pure virtual]\fP"
.PP
Creates a special scene node animator for doing automatic collision detection and response. 
.PP
See \fBISceneNodeAnimatorCollisionResponse\fP for details. 
.PP
\fBParameters:\fP
.RS 4
\fIworld,:\fP Triangle selector holding all triangles of the world with which the scene node may collide. You can create a triangle selector with \fBISceneManager::createTriangleSelector()\fP; 
.br
\fIsceneNode,:\fP SceneNode which should be manipulated. After you added this animator to the scene node, the scene node will not be able to move through walls and is affected by gravity. 
.br
\fIellipsoidRadius,:\fP Radius of the ellipsoid with which collision detection and response is done. If you have got a scene node, and you are unsure about how big the radius should be, you could use the following code to determine it: 
.PP
.nf
            core::aabbox<f32> box = yourSceneNode->getBoundingBox();
                 core::vector3df radius = box.MaxEdge - box.getCenter();

.fi
.PP
 
.br
\fIgravityPerSecond,:\fP Sets the gravity of the environment. A good example value would be \fBcore::vector3df\fP(0,-100.0f,0) for letting gravity affect all object to fall down. For bigger gravity, make increase the length of the vector. You can disable gravity by setting it to core::vector3df(0,0,0). 
.br
\fIellipsoidTranslation,:\fP By default, the ellipsoid for collision detection is created around the center of the scene node, which means that the ellipsoid surrounds it completely. If this is not what you want, you may specify a translation for the ellipsoid. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the animator. Attach it to a scene node with \fBISceneNode::addAnimator()\fP and the animator will cause it to do collision detection and response. If you no longer need the animator, you should call \fBISceneNodeAnimator::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNodeAnimator\fP* engine::scene::ISceneManager::createDeleteAnimator (u32 timeMs)\fC [pure virtual]\fP"
.PP
Creates a scene node animator, which deletes the scene node after some time automaticly. 
.PP
\fBParameters:\fP
.RS 4
\fIwhen,:\fP Time in milliseconds, after when the node will be deleted. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the animator. Attach it to a scene node with \fBISceneNode::addAnimator()\fP and the animator will animate it. If you no longer need the animator, you should call \fBISceneNodeAnimator::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNodeAnimator\fP* engine::scene::ISceneManager::createFlyCircleAnimator (const \fBcore::vector3df\fP & center, f32 radius, f32 speed = \fC0.001f\fP)\fC [pure virtual]\fP"
.PP
Creates a fly circle animator, which lets the attached scene node fly around a center. 
.PP
\fBParameters:\fP
.RS 4
\fIcenter,:\fP Center of the circle. 
.br
\fIradius,:\fP Radius of the circle. 
.br
\fIspeed,:\fP Specifies the speed of the flight. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the animator. Attach it to a scene node with \fBISceneNode::addAnimator()\fP and the animator will animate it. If you no longer need the animator, you should call \fBISceneNodeAnimator::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNodeAnimator\fP* engine::scene::ISceneManager::createFlyStraightAnimator (const \fBcore::vector3df\fP & startPoint, const \fBcore::vector3df\fP & endPoint, u32 timeForWay, bool loop = \fCfalse\fP)\fC [pure virtual]\fP"
.PP
Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. 
.PP
\fBParameters:\fP
.RS 4
\fIstartPoint,:\fP Start point of the line. 
.br
\fIendPoint,:\fP End point of the line. 
.br
\fItimeForWay,:\fP Time in milli seconds how long the node should need to move from the start point to the end point. 
.br
\fIloop,:\fP If set to false, the node stops when the end point is reached. If loop is true, the node begins again at the start. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the animator. Attach it to a scene node with \fBISceneNode::addAnimator()\fP and the animator will animate it. If you no longer need the animator, you should call \fBISceneNodeAnimator::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNodeAnimator\fP* engine::scene::ISceneManager::createFollowSplineAnimator (s32 startTime, const \fBcore::array\fP< \fBcore::vector3df\fP > & points, f32 speed = \fC1.0f\fP, f32 tightness = \fC0.5f\fP)\fC [pure virtual]\fP"
.PP
Creates a follow spline animator. 
.PP
The animator modifies the position of the attached scene node to make it follow a hermite spline. The code of the is based on a scene node Matthias Gall sent in. Thanks! I adapted the code just a little bit. Matthias wrote: Uses a subset of hermite splines: either cardinal splines (tightness != 0.5) or catmull-rom-splines (tightness == 0.5) but this is just my understanding of this stuff, I'm not a mathematician, so this might be wrong ;) 
.SS "virtual \fBIMetaTriangleSelector\fP* engine::scene::ISceneManager::createMetaTriangleSelector ()\fC [pure virtual]\fP"
.PP
Creates a meta triangle selector. 
.PP
A meta triangle selector is nothing more than a collection of one or more triangle selectors providing together the interface of one triangle selector. In this way, collision tests can be done with different triangle soups in one pass. 
.PP
\fBReturns:\fP
.RS 4
Returns the selector, or null if not successful. If you no longer need the selector, you should call \fBITriangleSelector::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneManager\fP* engine::scene::ISceneManager::createNewSceneManager ()\fC [pure virtual]\fP"
.PP
Creates a new scene manager. 
.PP
This can be used to easily draw and/or store two independent scenes at the same time. The mesh cache will be shared between all existing scene managers, which means if you load a mesh in the original scene manager using for example \fBgetMesh()\fP, the mesh will be available in all other scene managers too, without loading. The original/main scene manager will still be there and accessible via engineDevice::getSceneManager(). If you need input event in this new scene manager, for example for FPS cameras, you'll need to forward input to this manually: Just implement an \fBIEventReceiver\fP and call yourNewSceneManager->\fBpostEventFromUser()\fP, and return true so that the original scene manager doesn't get the event. Otherwise, all input will go automaticly to the main scene manager. If you no longer need the new scene manager, you should call \fBISceneManager::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.SS "virtual \fBITriangleSelector\fP* engine::scene::ISceneManager::createOctTreeTriangleSelector (\fBIMesh\fP * mesh, \fBISceneNode\fP * node, s32 minimalPolysPerNode = \fC32\fP)\fC [pure virtual]\fP"
.PP
Creates a Triangle Selector, optimized by an octtree. 
.PP
Triangle selectors can be used for doing collision detection. This triangle selector is optimized for huge amounts of triangle, it organizes them in an octtree. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call \fBISceneNode::setTriangleSelector()\fP for this. To create and attach a triangle selector is done like this: 
.PP
.nf
              ITriangleSelector* s = sceneManager->createOctTreeTriangleSelector(yourMesh,
                                yourSceneNode);
                 yourSceneNode->setTriangleSelector(s);
                 s->drop();

.fi
.PP
 For more informations and examples on this, take a look at the collision tutorial in the SDK. 
.PP
\fBParameters:\fP
.RS 4
\fImesh,:\fP Mesh of which the triangles are taken. 
.br
\fInode,:\fP Scene node of which visibility and transformation is used. 
.br
\fIminimalPolysPerNode,:\fP Specifies the minimal polygons contained a octree node. If a node gets less polys the this value, it will not be splitted into smaller nodes. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the selector, or null if not successful. If you no longer need the selector, you should call \fBITriangleSelector::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBISceneNodeAnimator\fP* engine::scene::ISceneManager::createRotationAnimator (const \fBcore::vector3df\fP & rotationPerSecond)\fC [pure virtual]\fP"
.PP
Creates a rotation animator, which rotates the attached scene node around itself. 
.PP
\fBParameters:\fP
.RS 4
\fIrotationPerSecond,:\fP Specifies the speed of the animation 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the animator. Attach it to a scene node with \fBISceneNode::addAnimator()\fP and the animator will animate it. If you no longer need the animator, you should call \fBISceneNodeAnimator::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBITriangleSelector\fP* engine::scene::ISceneManager::createTerrainTriangleSelector (\fBITerrainSceneNode\fP * node, s32 LOD = \fC0\fP)\fC [pure virtual]\fP"
.PP
Creates a triangle selector which can select triangles from a terrain scene node. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP Pointer to the created terrain scene node 
.br
\fI\fP Level of detail, 0 for highest detail. 
.RE
.PP

.SS "virtual \fBISceneNodeAnimator\fP* engine::scene::ISceneManager::createTextureAnimator (const \fBcore::array\fP< \fBvideo::ITexture\fP * > & textures, s32 timePerFrame, bool loop = \fCtrue\fP)\fC [pure virtual]\fP"
.PP
Creates a texture animator, which switches the textures of the target scene node based on a list of textures. 
.PP
\fBParameters:\fP
.RS 4
\fItextures,:\fP List of textures to use. 
.br
\fItimePerFrame,:\fP Time in milliseconds, how long any texture in the list should be visible. 
.br
\fIloop,:\fP If set to to false, the last texture remains set, and the animation stops. If set to true, the animation restarts with the first texture. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the animator. Attach it to a scene node with \fBISceneNode::addAnimator()\fP and the animator will animate it. If you no longer need the animator, you should call \fBISceneNodeAnimator::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBITriangleSelector\fP* engine::scene::ISceneManager::createTriangleSelector (\fBIMesh\fP * mesh, \fBISceneNode\fP * node)\fC [pure virtual]\fP"
.PP
Creates a simple \fBITriangleSelector\fP, based on a mesh. 
.PP
Triangle selectors can be used for doing collision detection. Don't use this selector for a huge amount of triangles like in Quake3 maps. Instead, use for example \fBISceneManager::createOctTreeTriangleSelector()\fP. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call \fBISceneNode::setTriangleSelector()\fP for this. To create and attach a triangle selector is done like this: 
.PP
.nf
           ITriangleSelector* s = sceneManager->createTriangleSelector(yourMesh,
                                yourSceneNode);
                 yourSceneNode->setTriangleSelector(s);
                 s->drop();

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fImesh,:\fP Mesh of which the triangles are taken. 
.br
\fInode,:\fP Scene node of which visibility and transformation is used. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the selector, or null if not successful. If you no longer need the selector, you should call \fBITriangleSelector::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBITriangleSelector\fP* engine::scene::ISceneManager::createTriangleSelectorFromBoundingBox (\fBISceneNode\fP * node)\fC [pure virtual]\fP"
.PP
Creates a simple dynamic \fBITriangleSelector\fP, based on a axis aligned bounding box. 
.PP
Triangle selectors can be used for doing collision detection. Every time when triangles are queried, the triangle selector gets the bounding box of the scene node, an creates new triangles. In this way, it works good with animated scene nodes. 
.PP
\fBParameters:\fP
.RS 4
\fInode,:\fP Scene node of which the bounding box, visibility and transformation is used. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the selector, or null if not successful. If you no longer need the selector, you should call \fBITriangleSelector::drop()\fP. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual void engine::scene::ISceneManager::drawAll ()\fC [pure virtual]\fP"
.PP
Draws all the scene nodes. 
.PP
This can only be invoked between IVideoDriver::beginScene() and IVideoDriver::endScene(). Please note that the scene is not only drawn when calling this, but also animated by existing scene node animators, culling of scene nodes is done, etc. 
.SS "virtual \fBICameraSceneNode\fP* engine::scene::ISceneManager::getActiveCamera ()\fC [pure virtual]\fP"
.PP
Returns the current active camera. 
.PP
\fBReturns:\fP
.RS 4
The active camera is returned. Note that this can be NULL, if there was no camera created yet. 
.RE
.PP

.SS "virtual \fBIAnimatedMesh\fP* engine::scene::ISceneManager::getMesh (const c8 * filename)\fC [pure virtual]\fP"
.PP
Returns pointer to an animateable mesh. Loads the file if not loaded already. 
.PP
If you want to remove a loaded mesh from the cache again, use removeMesh(). Currently there are the following mesh formats supported: Format Description  3D Studio (.3ds) Loader for 3D-Studio files which lots of 3D packages are able to export. Only static meshes are currently supported by this importer.   Cartography shop 4 (.csm) Cartography Shop is a modeling program for creating architecture and calculating lighting. engine can directly import .csm files thanks to the engineCSM library created by Saurav Mohapatra which is now integrated directly in engine. If you are using this loader, please note that you'll have to set the path of the textures before loading .csm files. You can do this using SceneManager->\fBgetParameters()\fP->setParameter(\fBscene::CSM_TEXTURE_PATH\fP, "path/to/your/textures");  COLLADA (.dae, .xml) COLLADA is an open Digital Asset Exchange Schema for the interactive 3D industry. There are exporters and importers for this format available for most of the big 3d packages at http://collada.org. engine can import COLLADA files by using the \fBISceneManager::getMesh()\fP method. COLLADA files need not contain only one single mesh but multiple meshes and a whole scene setup with lights, cameras and mesh instances, this loader can set up a scene as described by the COLLADA file instead of loading and returning one single mesh. By default, this loader behaves like the other loaders and does not create instances, but it can be switched into this mode by using SceneManager->\fBgetParameters()\fP->setParameter(COLLADA_CREATE_SCENE_INSTANCES, true); Created scene nodes will be named as the names of the nodes in the COLLADA file. The returned mesh is just a dummy object in this mode. Meshes included in the scene will be added into the scene manager with the following naming scheme: path/to/file/file.deameshname. The loading of such meshes is logged. Currently, this loader is able to create meshes (made of only polygons), lights, and cameras. Materials and animations are currently not supported but this will change with future releases.   Delgine DeleD (.dmf) DeleD (delgine.com) is a 3D editor and level-editor combined into one and is specifically designed for 3D game-development. With this loader, it is possible to directly load all geometry is as well as textures and lightmaps from .dmf files. To set texture and material paths, see \fBscene::DMF_USE_MATERIALS_DIRS\fP and \fBscene::DMF_TEXTURE_PATH\fP. It is also possible to flip the alpha texture by setting \fBscene::DMF_FLIP_ALPHA_TEXTURES\fP to true and to set the material transparent reference value by setting \fBscene::DMF_ALPHA_CHANNEL_REF\fP to a float between 0 and 1. The loader is based on Salvatore Russo's .dmf loader, I just changed some parts of it. Thanks to Salvatore for his work and for allowing me to use his code in engine and put it under engine's license. For newer and more enchanced versions of the loader, take a look at delgine.com.   DirectX (.x) Platform independent importer (so not D3D-only) for .x files. Most 3D packages can export these natively and there are several tools for them available. (e.g. the Maya exporter included in the DX SDK) .x files can include skeletal animations and engine is able to play and display them. Currently, engine only supports text encoded .x files.  Maya (.obj) Most 3D software can create .obj files which contain static geometry without material data. This importer for engine can load them directly.   Milkshape (.ms3d) .MS3D files contain models and sometimes skeletal animations from the Milkshape 3D modeling and animation software. This importer for engine can display and/or animate these files.   My3D (.my3d) .my3D is a flexible 3D file format. The My3DTools contains plug-ins to export .my3D files from several 3D packages. With this built-in importer, engine can read and display those files directly. This loader was written by Zhuck Dimitry who also created the whole My3DTools package. If you are using this loader, please note that you can set the path of the textures before loading .my3d files. You can do this using SceneManager->\fBgetParameters()\fP->setParameter(\fBscene::MY3D_TEXTURE_PATH\fP, "path/to/your/textures");   OCT (.oct) The oct file format contains 3D geometry and lightmaps and can be loaded directly by engine. OCT files
.br
 can be created by FSRad, Paul Nette's radiosity processor or exported from Blender using OCTTools which can be found in the exporters/OCTTools directory of the SDK. Thanks to Murphy McCauley for creating all this.  Pulsar LMTools (.lmts) LMTools is a set of tools (Windows & Linux) for creating lightmaps. engine can directly read .lmts files thanks to
.br
 the importer created by Jonas Petersen. If you are using this loader, please note that you can set the path of the textures before loading .lmts files. You can do this using SceneManager->\fBgetParameters()\fP->setParameter(\fBscene::LMTS_TEXTURE_PATH\fP, "path/to/your/textures"); Notes for
.br
 this version of the loader:
.br
.IP "\(bu" 2
It does not recognice/support user data in the *.lmts files.
.br

.IP "\(bu" 2
The TGAs generated by LMTools don't work in engine for some reason (the textures are upside down). Opening and resaving them in a graphics app will solve the problem.  
.PP
Quake 3 levels (.bsp) Quake 3 is a popular game by IDSoftware, and .pk3 files contain .bsp files and textures/lightmaps describing huge
.br
 prelighted levels. engine can read .pk3 and .bsp files directly and thus render Quake 3 levels directly. Written by Nikolaus Gebhardt enhanced by Dean P. Macri with the curved surfaces feature.   Quake 2 models (.md2) Quake 2 models are characters with morph target animation. engine can read, display and animate them directly with this importer.   
.PP
To load and display a mesh quickly, just do this: 
.PP
.nf
  SceneManager->addAnimatedMeshSceneNode(
                SceneManager->getMesh('yourmesh.3ds'));

.fi
.PP
 If you would like to implement and add your own file format loader to engine, see \fBaddExternalMeshLoader()\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename,:\fP Filename of the mesh to load. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns NULL if failed and the pointer to the mesh if successful. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual \fBIMeshCache\fP* engine::scene::ISceneManager::getMeshCache ()\fC [pure virtual]\fP"
.PP
Returns an interface to the mesh cache which is shared beween all existing scene managers. 
.PP
With this interface, it is possible to manually add new loaded meshes (if \fBISceneManager::getMesh()\fP is not sufficient), to remove them and to iterate through already loaded meshes. 
.SS "virtual \fBIStringParameters\fP* engine::scene::ISceneManager::getParameters ()\fC [pure virtual]\fP"
.PP
Returns interface to the parameters set in this scene. 
.PP
String parameters can be used by plugins and mesh loaders. For example the CMS and LMTS loader want a parameter named 'CSM_TexturePath' and 'LMTS_TexturePath' set to the path were attached textures can be found. See CSM_TEXTURE_PATH, LMTS_TEXTURE_PATH, MY3D_TEXTURE_PATH, COLLADA_CREATE_SCENE_INSTANCES, DMF_TEXTURE_PATH and DMF_USE_MATERIALS_DIRS 
.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::getRootSceneNode ()\fC [pure virtual]\fP"
.PP
Returns the root scene node. 
.PP
This is the scene node wich is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It will not be rendered and cannot be removed from the scene. 
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to the root scene node. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::getSceneNodeFromId (s32 id, \fBISceneNode\fP * start = \fC0\fP)\fC [pure virtual]\fP"
.PP
Returns the first scene node with the specified id. 
.PP
\fBParameters:\fP
.RS 4
\fIid,:\fP The id to search for 
.br
\fIstart,:\fP Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the first scene node with this id, and null if no scene node could be found. 
.RE
.PP

.SS "virtual \fBISceneNode\fP* engine::scene::ISceneManager::getSceneNodeFromName (const wchar_t * name, \fBISceneNode\fP * start = \fC0\fP)\fC [pure virtual]\fP"
.PP
Returns the first scene node with the specified name. 
.PP
\fBParameters:\fP
.RS 4
\fIstart,:\fP Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the first scene node with this id, and null if no scene node could be found. 
.RE
.PP

.SS "virtual \fBE_SCENE_NODE_RENDER_PASS\fP engine::scene::ISceneManager::getSceneNodeRenderPass ()\fC [pure virtual]\fP"
.PP
Returns current render pass. 
.PP
All scene nodes are being rendered in a specific order. First lights, cameras, sky boxes, solid geometry, and then transparent stuff. During the rendering process, scene nodes may want to know what the scene manager is rendering currently, because for example they registered for rendering twice, once for transparent geometry and once for solid. When knowing what rendering pass currently is active they can render the correct part of their geometry. 
.SS "virtual \fBvideo::IVideoDriver\fP* engine::scene::ISceneManager::getVideoDriver ()\fC [pure virtual]\fP"
.PP
Returns the video driver. 
.PP
\fBReturns:\fP
.RS 4
Returns pointer to the video Driver. This pointer should not be dropped. See \fBIUnknown::drop()\fP for more information. 
.RE
.PP

.SS "virtual bool engine::scene::ISceneManager::postEventFromUser (\fBSEvent\fP event)\fC [pure virtual]\fP"
.PP
Posts an input event to the environment. 
.PP
Usually you do not have to use this method, it is used by the internal engine. 
.SS "virtual void engine::scene::ISceneManager::registerNodeForRendering (\fBISceneNode\fP * node, \fBE_SCENE_NODE_RENDER_PASS\fP pass = \fCESNRP_AUTOMATIC\fP)\fC [pure virtual]\fP"
.PP
Registers a node for rendering it at a specific time. 
.PP
This method should only be used by SceneNodes when they get a \fBISceneNode::OnPreRender()\fP call. 
.PP
\fBParameters:\fP
.RS 4
\fInode,:\fP Node to register for drawing. Usually scene nodes would set 'this' as parameter here because they want to be drawn. 
.br
\fIpass,:\fP Specifies when the mode wants to be drawed in relation to the other nodes. For example, if the node is a shadow, it usually wants to be drawn after all other nodes and will use ESNRP_SHADOW for this. See E_SCENE_NODE_RENDER_PASS for details. 
.RE
.PP

.SS "virtual void engine::scene::ISceneManager::setActiveCamera (\fBICameraSceneNode\fP * camera)\fC [pure virtual]\fP"
.PP
Sets the currently active camera. 
.PP
The previous active camera will be deactivated. 
.PP
\fBParameters:\fP
.RS 4
\fIcamera,:\fP The new camera which should be active. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for LTE 3D Engine from the source code.
